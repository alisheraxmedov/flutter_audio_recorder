import 'dart:io';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:path_provider/path_provider.dart';
import 'package:recorder/core/services/transcription_service.dart';
import 'package:recorder/core/services/ai_analysis_service.dart';

/// Controller for AI transcription and analysis features
class AiController extends GetxController {
  final TranscriptionService _transcriptionService = TranscriptionService();
  final AiAnalysisService _analysisService = AiAnalysisService();

  // Audio file info
  final RxString audioPath = ''.obs;
  final RxString audioName = ''.obs;

  // Transcription state
  final RxString transcribedText = ''.obs;
  final RxBool isTranscribing = false.obs;
  final RxBool hasTranscription = false.obs;

  // Analysis state
  final RxString analysisResult = ''.obs;
  final RxBool isAnalyzing = false.obs;
  final Rx<AnalysisMode?> currentMode = Rx<AnalysisMode?>(null);

  // Tags
  final RxList<String> suggestedTags = <String>[].obs;

  // Error handling
  final RxString errorMessage = ''.obs;

  /// Load audio file for processing
  void loadAudio(String path) {
    audioPath.value = path;
    audioName.value = path.split(RegExp(r'[/\\]')).last;
    // Reset previous results
    transcribedText.value = '';
    analysisResult.value = '';
    hasTranscription.value = false;
    suggestedTags.clear();
    errorMessage.value = '';
  }

  /// Transcribe loaded audio file
  Future<void> transcribe({String language = 'uz'}) async {
    if (audioPath.isEmpty) {
      errorMessage.value = 'No audio file loaded';
      return;
    }

    isTranscribing.value = true;
    errorMessage.value = '';

    try {
      final result = await _transcriptionService.transcribeAudio(
        audioPath.value,
        language: language,
      );

      if (result != null) {
        transcribedText.value = result;
        hasTranscription.value = true;
        // Auto-suggest tags
        _suggestTags();
      } else {
        errorMessage.value = 'Transcription failed. Check API key.';
      }
    } catch (e) {
      errorMessage.value = 'Error: $e';
      debugPrint('Transcription error: $e');
    } finally {
      isTranscribing.value = false;
    }
  }

  /// Analyze transcribed text
  Future<void> analyze(AnalysisMode mode) async {
    if (transcribedText.isEmpty) {
      errorMessage.value = 'No text to analyze';
      return;
    }

    isAnalyzing.value = true;
    currentMode.value = mode;
    errorMessage.value = '';

    try {
      final result = await _analysisService.analyze(
        transcribedText.value,
        mode,
      );

      if (result != null) {
        analysisResult.value = result;
      } else {
        errorMessage.value = 'Analysis failed. Check API key.';
      }
    } catch (e) {
      errorMessage.value = 'Error: $e';
      debugPrint('Analysis error: $e');
    } finally {
      isAnalyzing.value = false;
    }
  }

  /// Suggest tags based on transcription
  Future<void> _suggestTags() async {
    if (transcribedText.isEmpty) return;

    final tags = await _analysisService.suggestTags(transcribedText.value);
    suggestedTags.assignAll(tags);
  }

  /// Export transcription as text file
  Future<String?> exportAsText() async {
    if (transcribedText.isEmpty) return null;

    try {
      final dir = await getApplicationDocumentsDirectory();
      final fileName = audioName.value.replaceAll(RegExp(r'\.[^.]+$'), '');
      final filePath = '${dir.path}/${fileName}_transcript.txt';

      final file = File(filePath);
      await file.writeAsString(transcribedText.value);

      return filePath;
    } catch (e) {
      debugPrint('Export text error: $e');
      return null;
    }
  }

  /// Export transcription as Markdown file
  Future<String?> exportAsMarkdown() async {
    if (transcribedText.isEmpty) return null;

    try {
      final dir = await getApplicationDocumentsDirectory();
      final fileName = audioName.value.replaceAll(RegExp(r'\.[^.]+$'), '');
      final filePath = '${dir.path}/${fileName}_transcript.md';

      final content =
          '''# Transcription: $audioName

## Original Text

$transcribedText

${analysisResult.isNotEmpty ? '''
## Analysis (${currentMode.value?.name ?? 'N/A'})

$analysisResult
''' : ''}

---
*Generated by Voice Recorder AI*
''';

      final file = File(filePath);
      await file.writeAsString(content);

      return filePath;
    } catch (e) {
      debugPrint('Export markdown error: $e');
      return null;
    }
  }

  /// Copy transcription to clipboard
  void copyToClipboard() {
    // Will be handled in UI with Clipboard.setData
  }

  /// Get mode display name
  String getModeDisplayName(AnalysisMode mode) {
    switch (mode) {
      case AnalysisMode.summarize:
        return 'Summary';
      case AnalysisMode.simplify:
        return 'Simplified';
      case AnalysisMode.actionItems:
        return 'Action Items';
      case AnalysisMode.format:
        return 'Formatted';
    }
  }
}
